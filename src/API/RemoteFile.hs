-- GENERATED
{-# LANGUAGE OverloadedStrings #-}
module API.RemoteFile where

import Text.Read (readMaybe)

import qualified Data.Aeson as A
import qualified Data.Aeson.Types as T
import qualified Utils as U

-- |
-- 
-- Represents a remote file
-- 
-- __id__ Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers.
-- 
-- -If the ID starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known.
-- 
-- -If downloadFile/addFileToDownloads is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original_path and "#url#" as the conversion string. Application must generate the file by downloading it to the specified location
-- 
-- __unique_id__ Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time
-- 
-- __is_uploading_active__ True, if the file is currently being uploaded (or a remote copy is being generated by some other means)
-- 
-- __is_uploading_completed__ True, if a remote copy is fully available
-- 
-- __uploaded_size__ Size of the remote available part of the file, in bytes; 0 if unknown
data RemoteFile = 

 RemoteFile { uploaded_size :: Maybe Int, is_uploading_completed :: Maybe Bool, is_uploading_active :: Maybe Bool, unique_id :: Maybe String, _id :: Maybe String }  deriving (Eq)

instance Show RemoteFile where
 show RemoteFile { uploaded_size=uploaded_size, is_uploading_completed=is_uploading_completed, is_uploading_active=is_uploading_active, unique_id=unique_id, _id=_id } =
  "RemoteFile" ++ U.cc [U.p "uploaded_size" uploaded_size, U.p "is_uploading_completed" is_uploading_completed, U.p "is_uploading_active" is_uploading_active, U.p "unique_id" unique_id, U.p "_id" _id ]

instance T.ToJSON RemoteFile where
 toJSON RemoteFile { uploaded_size = uploaded_size, is_uploading_completed = is_uploading_completed, is_uploading_active = is_uploading_active, unique_id = unique_id, _id = _id } =
  A.object [ "@type" A..= T.String "remoteFile", "uploaded_size" A..= uploaded_size, "is_uploading_completed" A..= is_uploading_completed, "is_uploading_active" A..= is_uploading_active, "unique_id" A..= unique_id, "id" A..= _id ]

instance T.FromJSON RemoteFile where
 parseJSON v@(T.Object obj) = do
  t <- obj A..: "@type" :: T.Parser String
  case t of
   "remoteFile" -> parseRemoteFile v
   _ -> mempty
  where
   parseRemoteFile :: A.Value -> T.Parser RemoteFile
   parseRemoteFile = A.withObject "RemoteFile" $ \o -> do
    uploaded_size <- mconcat [ o A..:? "uploaded_size", readMaybe <$> (o A..: "uploaded_size" :: T.Parser String)] :: T.Parser (Maybe Int)
    is_uploading_completed <- o A..:? "is_uploading_completed"
    is_uploading_active <- o A..:? "is_uploading_active"
    unique_id <- o A..:? "unique_id"
    _id <- o A..:? "id"
    return $ RemoteFile { uploaded_size = uploaded_size, is_uploading_completed = is_uploading_completed, is_uploading_active = is_uploading_active, unique_id = unique_id, _id = _id }
 parseJSON _ = mempty
